install.packages("chebpol")
?chebappxf
library("chebpol", lib.loc="~/R/win-library/3.1")
?chebappxf
install.packages("np")
library("chebpol", lib.loc="~/R/win-library/3.1")
?chebappxf
f <- function(x) exp(-sum(x^2))
## we want 3 dimensions, i.e. something like
## f(x,y,z) = exp(-(x^2 + y^2 + z^2))
## 8 points in each dimension
gridsize <- list(8,8,8)
# get the function values on the Chebyshev grid
values <- evalongrid(f,gridsize)
# make an approximation
ch <- chebappx(values)
## test it:
a <- runif(3,-1,1);ch(a)-f(a)
gridsize
ch
values
f(c(1,1,1))
f(c(1,1,8))
exp(-3)
exp(-66)
?evalongrid
g<- function(x) {a <- sum(x^2); ifelse(a == 0,0,exp(-1/a))}
evalongrid(g,dims=c(3,5))
g<- function(x) {a <- sum(x^2)}
evalongrid(g,dims=c(3,5))
g<- function(x) {a <- sum(x)}
evalongrid(g,dims=c(3,5))
chebknots(4)
f
g<- chebappxf(f)
g<- chebappxf(f, dims = c(3,5))
evalongrid(g,dims=c(3,5))
evalongrid(f,dims=c(3,5))
evalongrid(f,dims=c(2,2))
evalongrid(g,dims=c(2,2))
evalongrid(g,dims=c(6,6))
evalongrid(f,dims=c(6,6))
t<-chebknots(c(3,5))
plot(t)
t
chebknots(c(3,5))
chebknots(c(5,5))
Q = 10
mu = 1
sigma = 1
pr = 3
pw = 1
alpha = .3
eta = 4
beta = .95
N = 1000
# rob had bug with iterated chebappx
# appf<- chebappxf(f) %>% vectorize
pi<- function(i, s, q){
pr*s - pw*q - alpha*(i - s) - eta*(q>0)
}
pi(0,0,q)
pi(0,0,1)
?integrate
?vectorize
?Vectorize
?chebknots
varSave<-'../variables/'
ex.mods<-'modules/'
library('fExtremes')
library('plyr')
library('reshape2')
library('dplyr')
library('doParallel')
library('chebpol')
library('np')
registerDoParallel(cores=20)
l_ply(dir(ex.mods), function(l) source(paste(ex.mods, l, sep="")))
?chebknots
CCP_key<- chebknots(12, c(0,Q))
CCP_key
?runif
CCP<- data.frame(
CCP_key<- chebknots(12, c(0,Q))
prob_order<- rrunif(12)
)
CCP<- data.frame(
key = chebknots(12, c(0,Q)),
prob_order = rrunif(12)
)
CCP<- data.frame(
key = chebknots(12, c(0,Q)),
prob_order = runif(12)
)
View(CCP)
chebknots(12, c(0,Q))
CCP<- data.frame(
key = chebknots(12, c(0,Q))[[1]],
prob_order = runif(12)
)
View(CCP)
?chebappxf
f<- function(key){
CCP$prob_order[key]
}
f<- function(key){
CCP$prob_order[key]
}
chebappxf(f)
f<- function(key){
CCP$prob_order[key]
}
chebappxf(f, dims)
dims = 12
# rob had bug with iterated chebappx
# appf<- chebappxf(f) %>% vectorize
pi<- function(i, s, q){
pr*s - pw*q - alpha*(i - s) - eta*(q>0)
}
CCP<- data.frame(
key = chebknots(dims, c(0,Q))[[1]],
prob_order = runif(dims)
)
# Testing chebappxf. Update key to i later and figure out where to get s.
f<- function(key){
CCP$prob_order[key]
}
chebappxf(f, dims)
chebappxf(f, dims, c(0,Q))
f_tilda<- chebappxf(f, dims, c(0,Q))
f_tilda(5)
View(CCP)
f_tilda(5.65263096)
evalongrid(f_tilda,dims)
f <- function(y) uniroot(function(x) x-y[[1]]*cos(pi*x^2),lower=0,upper=1)$root*sum(y^2)
# approximate it
ch <- chebappxf(f,c(12,12),intervals=list(c(0,2),c(0,1)))
# test it:
a <- c(runif(1,0,2),runif(1,0,1)); ch(a); f(a)
f <- function(y) uniroot(function(x) x-y[[1]]*cos(pi*x^2),lower=0,upper=1)$root*sum(y^2)
# approximate it
ch <- chebappxf(f,c(12,12),intervals=list(c(0,2),c(0,1)))
# test it:
a <- c(runif(1,0,2),runif(1,0,1)); ch(a); f(a)
Q = 10
mu = 1
sigma = 1
pr = 3
pw = 1
alpha = .3
eta = 4
beta = .95
N = 1000
dims = 12
# rob had bug with iterated chebappx
# appf<- chebappxf(f) %>% vectorize
pi_<- function(i, s, q){
pr*s - pw*q - alpha*(i - s) - eta*(q>0)
}
CCP<- data.frame(
key = chebknots(dims, c(0,Q))[[1]],
prob_order = runif(dims)
)
# Testing chebappxf. Update key to i later and figure out where to get s.
f<- function(key){
CCP$prob_order[CCP$key==key]
}
f_tilda<- chebappxf(f, dims, c(0,Q))
f_tilda(5.65263096)  #When this returns 0.690786510 we know we're using chebappxf correctly.
evalongrid(f_tilda,dims)
